<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OSRM Walking Route with Elevation</title>
    <style>
        #map {
            height: 500px;
            width: 100%;
        }
        #distanceInput {
            margin: 10px;
        }
        #output {
            margin-top: 10px;
        }
        #elevationChart {
            width: 100%;
            height: 300px;
        }
    </style>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://unpkg.com/@turf/turf@6"></script>
</head>
<body>

<h3>Generate Walking Route with OSRM Trip API and Elevation Data</h3>
<input type="number" id="distanceInput" placeholder="Enter distance in km" />
<label for="elevationSelect">Elevation Change:</label>
<select id="elevationSelect">
    <option value="">Select...</option>
    <option value="0-200">0-200</option>
    <option value="200-400">200-400</option>
    <option value="400-600">400-600</option>
    <option value="600-800">600-800</option>
    <option value="800-1000">800-1000</option>
    <option value="1000+">1000+</option>
</select>
<button onclick="generateAndFilterRoutes()">Generate and Filter Route</button>
<div id="map"></div>
<div id="output"></div>
<canvas id="elevationChart"></canvas>

<script>
    let map, userLocation;
    let currentRoute; // 用于存储最后显示的路径
    const tolerance = 0.5 * 1000; // 容忍误差设置为500米
    const batchSize = 5; // 每次并行生成5条路径
    let chartInstance; // 保存当前图表实例
    let poiMarkers = []; // 保存POI的标记
    let poiList = []; // 保存POI的位置信息
    let routesData = []; // 存储生成的30条路径数据

    // 初始化地图
    map = L.map('map').setView([51.505, -0.09], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '© OpenStreetMap'
    }).addTo(map);

    // 获取用户的当前位置
    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
            (position) => {
                userLocation = {
                    lat: position.coords.latitude,
                    lng: position.coords.longitude,
                };

                map.setView(userLocation, 14);

                // 在用户位置添加标记
                L.marker(userLocation).addTo(map);
            },
            () => {
                alert("Geolocation failed.");
            }
        );
    } else {
        alert("Your browser doesn't support geolocation.");
    }

    // 主方法：生成并筛选路径
    async function generateAndFilterRoutes() {
        document.getElementById('output').innerHTML = ''; // 清空输出区域
        routesData = []; // 清空路径数据

        const inputDistance = parseFloat(document.getElementById('distanceInput').value) * 1000; // 用户输入的距离（米）
        const selectedRange = document.getElementById('elevationSelect').value; // 用户选择的Elevation Change

        if (!inputDistance || inputDistance <= 0) {
            alert('Please enter a valid distance.');
            return;
        }

        if (!selectedRange) {
            alert('Please select an elevation change range.');
            return;
        }

        // 分批生成路径
        for (let i = 0; i < 30; i += batchSize) {
            const promises = [];
            for (let j = 0; j < batchSize && i + j < 30; j++) {
                promises.push(generateRoute(i + j, inputDistance));
            }
            await Promise.all(promises);
        }

        console.log("Generated Routes:");
        routesData.forEach((route, index) => {
            console.log(
                `Route ${index + 1}: Distance = ${(route.distance / 1000).toFixed(2)} km, Elevation Change = ${route.elevationChange} m, POIs = ${route.poiCount}`
            );
        });

        // 筛选符合条件的路径
        filterRoutesByElevationChange(selectedRange);
    }

    async function generateRoute(routeIndex, inputDistance) {
        if (poiList.length === 0) {
            await fetchPOIs(inputDistance / 2);
        }

        const waypoints = generatePrecisePoints(userLocation, inputDistance);

        const coords = waypoints.map(p => `${p.lng},${p.lat}`).join(';');
        const query = `http://localhost:5050/trip/v1/foot/${userLocation.lng},${userLocation.lat};${coords}?roundtrip=true&source=first&destination=last&geometries=geojson`;

        try {
            const response = await fetch(query);
            const data = await response.json();

            if (data.trips && data.trips.length > 0) {
                const trip = data.trips[0];
                const coordinates = trip.geometry.coordinates.map(coord => [coord[1], coord[0]]);
                const actualDistance = trip.distance;

                if (Math.abs(actualDistance - inputDistance) > tolerance) {
                    return;
                }

                const elevationData = await getElevationData(coordinates);
                const { totalAscent } = calculateElevationStats(elevationData);
                const poiCount = countPOIsOnRoute(coordinates);

                routesData.push({
                    routeIndex,
                    coordinates,
                    distance: actualDistance,
                    elevationChange: totalAscent + totalAscent,
                    poiCount,
                });
            }
        } catch (error) {
            console.error('Error generating route:', error);
        }
    }

    function filterRoutesByElevationChange(selectedRange) {
    const [min, max] = selectedRange === '1000+'
        ? [1000, Infinity]
        : selectedRange.split('-').map(Number);

    const filteredRoutes = routesData.filter(route =>
        route.elevationChange >= min && route.elevationChange < max
    );

    if (filteredRoutes.length === 0) {
        const elevationValues = routesData.map(route => route.elevationChange);
        const minElevation = Math.min(...elevationValues);
        const maxElevation = Math.max(...elevationValues);
        alert(`No routes found. Minimum elevation change: ${minElevation} m, Maximum elevation change: ${maxElevation} m`);
        return;
    }

    const selectedRoute = filteredRoutes[0];

    // 清除当前地图上的路径和 POI 标注
    if (currentRoute) {
        map.removeLayer(currentRoute);
    }
    clearPOIMarkers();

    // 在地图上绘制选中路径
    currentRoute = L.polyline(selectedRoute.coordinates, { color: 'red' }).addTo(map);
    map.fitBounds(currentRoute.getBounds());

    // 标注路径经过的 POI
    countPOIsOnRoute(selectedRoute.coordinates);

    // 更新前端显示信息
    document.getElementById('output').innerHTML = `Selected Route: Distance = ${(selectedRoute.distance / 1000).toFixed(2)} km, Elevation Change = ${selectedRoute.elevationChange} m, POIs = ${selectedRoute.poiCount}`;
    drawElevationChart(selectedRoute.coordinates);
}

    function generatePrecisePoints(origin, totalDistance) {
        const points = [];
        const numberOfPoints = Math.max(3, Math.floor(totalDistance / 2000));
        const segmentDistance = totalDistance / numberOfPoints;

        for (let i = 0; i < numberOfPoints; i++) {
            points.push(calculateDestination(origin, segmentDistance));
        }
        return points;
    }

    function calculateDestination(origin, distance) {
        const earthRadius = 6371e3;
        const angularDistance = distance / earthRadius;
        const bearing = Math.random() * 2 * Math.PI;

        const lat1 = origin.lat * Math.PI / 180;
        const lng1 = origin.lng * Math.PI / 180;

        const lat2 = Math.asin(Math.sin(lat1) * Math.cos(angularDistance) +
            Math.cos(lat1) * Math.sin(angularDistance) * Math.cos(bearing));
        const lng2 = lng1 + Math.atan2(Math.sin(bearing) * Math.sin(angularDistance) * Math.cos(lat1),
            Math.cos(angularDistance) - Math.sin(lat1) * Math.sin(lat2));

        return {
            lat: lat2 * 180 / Math.PI,
            lng: lng2 * 180 / Math.PI
        };
    }

    async function fetchPOIs(radius) {
        const query = `[out:json];(node["tourism"="attraction"](around:${radius},${userLocation.lat},${userLocation.lng});
        way["tourism"="attraction"](around:${radius},${userLocation.lat},${userLocation.lng});
        relation["tourism"="attraction"](around:${radius},${userLocation.lat},${userLocation.lng});
        node["historic"="monument"](around:${radius},${userLocation.lat},${userLocation.lng});
        way["historic"="monument"](around:${radius},${userLocation.lat},${userLocation.lng});
        relation["historic"="monument"](around:${radius},${userLocation.lat},${userLocation.lng});
        node["leisure"="park"](around:${radius},${userLocation.lat},${userLocation.lng});
        way["leisure"="park"](around:${radius},${userLocation.lat},${userLocation.lng});
        relation["leisure"="park"](around:${radius},${userLocation.lat},${userLocation.lng}););out center;`;

        const url = `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`;

        try {
            const response = await fetch(url);
            const data = await response.json();

            poiList = [];
            data.elements.forEach(element => {
                const lat = element.lat || element.center.lat;
                const lng = element.lon || element.center.lon;
                const name = element.tags.name || 'Unnamed POI';
                poiList.push({ lat, lng, name });
            });
        } catch (error) {
            console.error('Error fetching POIs:', error);
        }
    }

    function clearPOIMarkers() {
        poiMarkers.forEach(marker => map.removeLayer(marker));
        poiMarkers = [];
    }

    function countPOIsOnRoute(coordinates) {
        const bufferRadius = 0.1;
        const visitedPOIs = new Set();

        coordinates.forEach(([lat, lng]) => {
            const point = turf.point([lng, lat]);

            poiList.forEach((poi, index) => {
                const poiPoint = turf.point([poi.lng, poi.lat]);
                const buffered = turf.buffer(poiPoint, bufferRadius, { units: 'kilometers' });

                if (turf.booleanPointInPolygon(point, buffered)) {
                    visitedPOIs.add(index);
                    const marker = L.marker([poi.lat, poi.lng]).addTo(map)
                        .bindPopup(poi.name);
                    poiMarkers.push(marker);
                }
            });
        });

        return visitedPOIs.size;
    }

    async function getElevationData(coordinates) {
        const path = coordinates.map(coord => `${coord[0]},${coord[1]}`).join('|');
        const elevationUrl = `http://localhost:3000/elevation?path=${path}&samples=200`;

        try {
            const response = await fetch(elevationUrl);
            const data = await response.json();
            if (data.results && data.results.length > 0) {
                return data.results.map(result => result.elevation);
            } else {
                console.error('Error fetching elevation data:', data);
                return [];
            }
        } catch (error) {
            console.error('Error fetching elevation data:', error);
            return [];
        }
    }

    function calculateElevationStats(elevations) {
        let totalAscent = 0;
        let totalDescent = 0;

        for (let i = 1; i < elevations.length; i++) {
            const diff = elevations[i] - elevations[i - 1];
            if (diff > 0) {
                totalAscent += diff;
            } else {
                totalDescent += Math.abs(diff);
            }
        }

        return {
            totalAscent: Math.round(totalAscent),
            totalDescent: Math.round(totalDescent),
        };
    }

    function drawElevationChart(elevations) {
        const ctx = document.getElementById('elevationChart').getContext('2d');

        if (chartInstance) {
            chartInstance.destroy();
        }

        chartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                labels: elevations.map((_, index) => index),
                datasets: [{
                    label: 'Elevation (m)',
                    data: elevations,
                    fill: false,
                    borderColor: 'blue',
                    tension: 0.1
                }]
            },
            options: {
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Sample Points'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Elevation (m)'
                        }
                    }
                }
            }
        });
    }
</script>

</body>
</html>
